import Elysia, { t } from "elysia";
import { betterAuthPlugin } from "@server/middlewares/auth";
import { AiService } from "@server/utils/ai";
import { GithubService } from "@server/utils/github";
import { prisma } from "@repo/db";
import { ChatGoogleGenerativeAI } from "@langchain/google-genai";
import { HumanMessage, SystemMessage, AIMessage, type BaseMessage } from "@langchain/core/messages";
import { SandboxManager } from "@server/utils/sandbox";

const CreateProjectWithAiSchema = {
  body: t.Object({
    name: t.String(),
    description: t.String(),
    template: t.Optional(t.String()),
    prompt: t.String(),
  }),
};

export const aiRouter = new Elysia()
  .use(betterAuthPlugin)
  .guard({ auth: true, detail: { tags: ["AI Orchestration"] } }, (app) =>
    app.post(
      "/ai/initialize-from-prompt",
      async ({ user, body }) => {
        const model = new ChatGoogleGenerativeAI({
          model: "gemini-2.5-flash",
          temperature: 0.1,
          apiKey: process.env.GEMINI_API_KEY,
        });

        const promptSys = `You are a project manager. The user wants to build an app: "${body.prompt}".
        Create a short, catchy "name" (lowercase, kebab-case, no spaces, max 20 chars) and a 1-sentence "description".
        Return ONLY raw JSON, no markdown formatting.
        Format: {"name": "app-name", "description": "Short desc."}`;
        
        const response = await model.invoke(promptSys);
        let metadata = { name: "generated-app", description: "Created from prompt" };
        try {
           const parsed = JSON.parse(response.content.toString().trim());
           if (parsed.name) metadata.name = parsed.name;
           if (parsed.description) metadata.description = parsed.description;
        } catch(e) {
           console.log("Failed to parse metadata", e);
        }

        const finalName = body.name || metadata.name;
        const finalDescription = body.description || metadata.description;

        const result = await prisma.$transaction(async (tx) => {
          const project = await tx.project.create({
            data: {
              name: finalName,
              description: finalDescription,
              template: body.template || "react",
              userId: user.id,
            },
          });

          const chatSession = await tx.chatSession.create({
            data: {
              projectId: project.id,
              userId: user.id,
              title: "Initial Generation",
            },
          });
          await tx.message.create({
            data: {
              chatSessionId: chatSession.id,
              role: "USER",
              content: body.prompt,
            },
          });
          
          return { project };
        });

        // Generate fallback files and Github Repo instantly so the sandbox can start empty
        const initialFiles = [];
        if (body.template === "react" || !body.template) {
          initialFiles.push(
            {
              path: "package.json",
              content: JSON.stringify({
                name: finalName,
                version: "0.0.0",
                scripts: { dev: "vite", build: "vite build" },
                dependencies: { react: "^18.2.0", "react-dom": "^18.2.0" },
                devDependencies: { "vite": "^5.2.0", "@vitejs/plugin-react": "^4.2.1" }
              }, null, 2)
            },
            {
              path: "index.html",
              content: `<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <title>${finalName}</title>\n  </head>\n  <body>\n    <div id="root"></div>\n    <script type="module" src="/src/main.jsx"></script>\n  </body>\n</html>`
            },
             {
              path: "src/main.jsx",
              content: `import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App.jsx';\n\nReactDOM.createRoot(document.getElementById('root')).render(<App />);`
            },
            {
              path: "src/App.jsx",
              content: `export default function App() {\n  return <div>Generating your app...</div>;\n}`
            }
          );
        }

        for (const file of initialFiles) {
          await prisma.fileSnapshot.create({
            data: { projectId: result.project.id, filePath: file.path, content: file.content }
          });
        }

        try {
          const repoData = await GithubService.createRepository(
            user.id,
            result.project.name,
            result.project.description || "Generated by Lynx Code AI"
          );

          if (initialFiles.length > 0) {
            await GithubService.commitFiles(user.id, {
              owner: repoData.owner.login,
              repo: repoData.name,
              message: "Initial commit",
              files: initialFiles,
            });
          }

          const updatedProject = await prisma.project.update({
            where: { id: result.project.id },
            data: {
              githubRepoUrl: repoData.html_url,
              githubRepoOwner: repoData.owner.login,
              githubRepoName: repoData.name,
            },
          });
          
          return { project: updatedProject, githubUrl: repoData.html_url };
        } catch (githubError: any) {
          console.error("GitHub Sync Error: ", githubError.message);
          return { project: result.project };
        }
      },
      CreateProjectWithAiSchema
    )
    .post("/ai/stream-chat", async ({ body, user }) => {
      const { prompt, projectId, chatSessionId } = body as { prompt: string, projectId: string, chatSessionId?: string };
      
      const stream = new ReadableStream({
        async start(controller) {
          try {
            // Find the chat session fallback, or create a new one.
            let activeSessionId = chatSessionId;
            if (!activeSessionId) {
              const latestSession = await prisma.chatSession.findFirst({
                where: { projectId, userId: user.id },
                orderBy: { createdAt: "desc" }
              });
              
              if (latestSession) {
                activeSessionId = latestSession.id;
              } else {
                const newSession = await prisma.chatSession.create({
                  data: { projectId, userId: user.id, title: "Workspace Chat" },
                });
                activeSessionId = newSession.id;
              }
            }

            // Fetch history
            const history = await prisma.message.findMany({
              where: { chatSessionId: activeSessionId },
              orderBy: { createdAt: "asc" },
            });

            // Fetch current project files for AI context!
            const currentFiles = await prisma.fileSnapshot.findMany({
              where: { projectId },
            });
            let fileContextStr = "\n\n### Current Project Files\n";
            if (currentFiles.length === 0) {
              fileContextStr += "No files exist yet.";
            } else {
              currentFiles.forEach(f => {
                fileContextStr += `\n--- ${f.filePath} ---\n${f.content}\n`;
              });
            }

            // Reconstructing langchain message history
            const messages: BaseMessage[] = [
              new SystemMessage(`You are Lynx AI, an expert AI developer assistant inside a modern IDE.
You have access to a fully functional React/Node development environment. Your primary goal is to solve the user's problem by writing robust, production-ready, beautiful code.

### Guidelines
1. **Be concise:** Jump directly to code unless explanation is absolutely necessary.
2. **Write clean UI:** Always leverage modern HTML5/CSS3. If using Tailwind or Vanilla CSS, ensure high aesthetic quality, smooth animations, and responsive design natively. E.g. dark modes, rounded corners, drop shadows.
3. **Architecture:** Keep files modular. Produce small, reusable functions/components.
4. **Context Awareness:** Act upon the CURRENT PROJECT FILES provided below. Do not recreate existing files unless you are modifying them. If the user asks for a completely different app, use the \`<boltAction type="delete" filePath="...">\` tag to clear out old unneeded files.
5. **Code Quality:** Ensure the code is production-ready, follows best practices, and is well-documented.
6. **Security:** Ensure the code is secure and follows best practices.
7. **Performance:** Ensure the code is performant and follows best practices.
8. **Remember:** Do not use comments in json files.
### Artifact Construction
All generated code modifications and new files MUST be wrapped in special XML <boltArtifact> tags so the workspace can compile them seamlessly.
Inside the artifact, use <boltAction> tags to specify exact file operations.

Example Rules:
- \`id\`: unique string like "feature-xxx"
- \`type="file"\` or \`type="delete"\`: for writing to files or deleting files.
- \`filePath\`: exact absolute or relative path, e.g. "src/components/Button.tsx"

<boltArtifact id="feature-add-hero" title="Add Hero Section">
  <boltAction type="delete" filePath="src/OldComponent.jsx"></boltAction>
  <boltAction type="file" filePath="src/Hero.jsx">
export default function Hero() { 
  return <div className="hero bg-black text-white p-8 rounded-xl shadow-2xl">Hi</div>; 
}
  </boltAction>
</boltArtifact>

IMPORTANT: Do not skip code, do not use placeholders like "// logic here". Output the full, complete code inside each <boltAction> block. If you are modifying a file, output the ENTIRE file content.${fileContextStr}`),
            ];
            
            for (const msg of history) {
              const role = msg.role.toUpperCase();
              if (role === "USER") messages.push(new HumanMessage(msg.content));
              else if (role === "ASSISTANT") messages.push(new AIMessage(msg.content));
            }
            messages.push(new HumanMessage(prompt));

            // Save new user prompt
            await prisma.message.create({
              data: { chatSessionId: activeSessionId, role: "USER", content: prompt },
            });

            const model = new ChatGoogleGenerativeAI({
              model: "gemini-2.5-flash",
              temperature: 0.2,
              apiKey: process.env.GEMINI_API_KEY,
            });

            const responseStream = await model.stream(messages);
            let fullResponse = "";

            for await (const chunk of responseStream) {
              if (chunk.content) {
                const textChunk = chunk.content.toString();
                fullResponse += textChunk;
                controller.enqueue(new TextEncoder().encode(textChunk));
              }
            }

            // Processing: save AI response and sync files before closing the stream
            // so frontend fetch hooks can find them immediately
            const assistantMessage = await prisma.message.create({
              data: { chatSessionId: activeSessionId, role: "ASSISTANT", content: fullResponse },
            });

            const generatedFiles = AiService.parseCodeBlocks(fullResponse);
            
            await Promise.all(
              generatedFiles.map(async (action) => {
                if (action.type === "delete") {
                  await prisma.fileSnapshot.deleteMany({
                    where: { projectId, filePath: action.path }
                  });
                  await SandboxManager.deleteFile(projectId, action.path);
                  
                  await prisma.fileChange.create({
                    data: {
                      projectId,
                      chatSessionId: activeSessionId,
                      messageId: assistantMessage.id,
                      changeType: "DELETE",
                      filePath: action.path,
                      createdBy: "AI",
                    }
                  });
                } else {
                  await prisma.fileSnapshot.upsert({
                    where: { projectId_filePath: { projectId, filePath: action.path } },
                    update: { content: action.content },
                    create: { projectId, filePath: action.path, content: action.content },
                  });
                  
                  await SandboxManager.syncFileToSandbox(projectId, action.path, action.content);
                  
                  await prisma.fileChange.create({
                    data: {
                      projectId,
                      chatSessionId: activeSessionId,
                      messageId: assistantMessage.id,
                      changeType: "MODIFY", 
                      filePath: action.path,
                      contentAfter: action.content,
                      createdBy: "AI",
                    }
                  });
                }
              })
            );
            controller.close();

          } catch (error) {
            console.error("Stream Error:", error);
            controller.enqueue(new TextEncoder().encode("\n[Error: Disconnected]"));
            controller.close();
          }
        }
      });

      return new Response(stream, { 
        headers: { 
          "Content-Type": "text/plain; charset=utf-8",
          "Cache-Control": "no-cache"
        } 
      });
    })
  );
